\documentclass[onecolumn,draftclsnofoot, 10pt, compsoc]{IEEEtran}

\usepackage{graphicx}
\usepackage[section]{placeins}
\usepackage{caption}

\usepackage{amssymb}                                         
\usepackage{amsmath}                                         
\usepackage{amsthm}                                

\usepackage{alltt}                                           
\usepackage{float}
\usepackage{color}
\usepackage{url}

\usepackage{balance}
\usepackage[TABBOTCAP, tight]{subfigure}
\usepackage{enumitem}
\usepackage{pstricks, pst-node}
\usepackage{url}
\usepackage{setspace}

\usepackage{etoolbox}
\AtBeginEnvironment{quote}{\singlespacing\vspace{-\topsep}\small}

%\input{pygments.tex}

\usepackage{geometry}
\geometry{left=0.75in,right=0.75in,top=0.75in,bottom=0.75in}
\parindent = 0.0 in
\parskip = 0.1 in


\def \ParSpace{\vspace{.75em}}
\def \GroupNumber{		17}
\def \Jeremy{			Jeremy Fischer}
\def \Roger{			Yipeng Song}
\def \Class{		Introduction To Artificial Intelligence}
\def \Assn{		HW-1: Uninformed and Informed Search}
\def \School{	Oregon State University}
\def \Professor{		Professor Rebecca Hutchinson}

\newcommand{\cred}[1]{{\color{red}#1}}
\newcommand{\cblue}[1]{{\color{blue}#1}}

\newcommand{\NameSigPair}[1]{
		\par
		\makebox[2.75in][r]{#1} \hfil 	\makebox[3.25in]{\makebox[2.25in]{\hrulefill} \hfill			
		\makebox[.75in]{\hrulefill}}
		\par\vspace{-12pt} \textit{
			\tiny\noindent
			\makebox[2.75in]{} \hfil		
			\makebox[3.25in]{
				\makebox[2.25in][r]{Signature} \hfill	\makebox[.75in][r]{Date}
			}
		}
}










%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
\begin{titlepage}
    \pagenumbering{gobble}
    \begin{singlespace}
    	\includegraphics[height=4cm]{coe.eps}
        \hfill  
        \par\vspace{.2in}
        \centering
        \scshape{
            \vspace{.5in}
            \textbf{\Large\Assn}\par
            \textbf{\large\Class}\par
            \large{
            	\today \\Spring Term
        	}
            \vfill
            {\large Prepared for}\par
            \huge \School\par
            \vspace{5pt}
            {\Large{\Professor}\par}
            {\large Prepared by }\par
           % Group\GroupNumber\par
            \vspace{5pt}
            {\Large
                {\Jeremy}\par
                {\Roger}\par
            }
            \vspace{20pt}
        }

    \end{singlespace}
\end{titlepage}
\newpage
\pagenumbering{arabic}

\tableofcontents
\newpage
% 7. uncomment this (if applicable). Consider adding a page break.
%\listoffigures
%\listoftables
\clearpage


	\section{Methodology}	
	\noindent \textbf{Usage:} \\
    \textbf{Breadth First Search:} \\python source.py testStart1.txt testGoal1.txt bfs output.txt\\
    \textbf{Depth First Search:} \\python source.py testStart1.txt testGoal1.txt dfs output.txt\\
    \textbf{Iterative Deepening Depth First Search:} \\python source.py testStart1.txt testGoal1.txt iddfs output.txt\\
    \textbf{A-Star Search:} \\python source.py testStart1.txt testGoal1.txt astar output.txt\\
    
    In this assignment, we use Python language to find the solution to wolves and chicks puzzle by using the uninformed and informed searching algorithms. For uninformed search, we implement Breadth First Search (BFS), Depth First Search (DFS), and Iterative Deepening Depth First Search (IDDFS). For informed search, we implement A-Star Search (A*). 
    
	\subsection{Breadth First Search}
	The BFS searching algorithm will expand every single node in the tree level by level until we reach the goal state. Starting at the root, after visiting one node, this algorithm will append all of its neighbor nodes to the end of the list and will not continue to the next level of the tree until every neighbor node has been visited. To implement this, we can use a First In First Out (FIFO) queue. Thus, the first node in the queue will be expanded first.
	
	\subsection{Depth First Search}
	The DFS searching function is implemented very similarly to the BFS, but instead of adding the neighbor nodes to the end of the queue, they are added to the front. Therefore, this algorithm will go as far as possible along each branch before backtracking. To implement this, we can use a Last In First Out (LIFO) queue. Thus, it will continue to explore one path until a terminal.

    \subsection{Iterative Deepening Depth First Search}
    The IDDFS will start at the root node and repeatedly applies depth first searching with increasing depth limits until the goal is found. We set the maximum depth to 1500 so it will return false, meaning no solution is found once it hits the max depth limit. This limit is set to ensure the program will not run too long before it ends up with a final decision.

	
	\subsection{A-Star Search}
	For the A-Star Search, we first made a heuristic function, H(n) = 2*(n-2) + 1 = 2n - 3. Suppose there are n animals on the right bank of the river. Then we will need at least 2 moves to move the first (n-2) animals to the left side of the bank and another move to take the rest two animals. Therefore, the optimal path will need at least 2*(n-2) + 1 = 2n - 3 moves to reach our goal. Thus, we set our heuristic function to be H(n) = 2n - 3 to calculate the least number of moves that we need based on the number of animals on the right bank. For the rest of this searching algorithm, we use the priority queue to pop the node that has the shortest path cost and expand until we reach the goal.  
	
	
	
	
	\section{Results}
	\begin{center}
    \begin{tabular}{|l|l|l|l|l|}
        \hline
        & \textbf{BFS} & \textbf{DFS} & \textbf{IDDFS} & \textbf{A-Star} \\ \hline
        \textbf{Test 1} & Solution: 11 & Solution: 11 & Solution: 11 & Solution: 11 \\
        & Expanded: 14 & Expanded: 11 & Expanded: 84 & Expanded: 29 \\ \hline
        \textbf{Test 2} & Solution: 31 & Solution: 31 & Solution: 31 & Solution: 31 \\
        & Expanded: 54 & Expanded: 45 & Expanded: 891 & Expanded: 50 \\ \hline
        \textbf{Test 3} & Solution: 387 & Solution: 953 & Solution: 951 & Solution: 387 \\
        & Expanded: 1344 & Expanded: 1230 & Expanded: 713088 & Expanded: 1281 \\ \hline
    \end{tabular}
\end{center}
	
	
	
	
	
	\section{Discussion}
	From the table above, we notice that all four searching algorithms give the same solution path number for the first two tests. In addition, BFS, DFS, and A-Star out performed IDDFS as the nodes expanded are a lot less than the ones in IDDFS. 
    \indent IDDFS took a very long time on the larger data set (both test 2 and test 3), even though it found the best solution it expanded 713088 nodes which is much more than any other algorithm.

	
	
	
	
	\section{Conclusion}
	Among the 4 algorithms, theoretically the A-star search will perform the best, if given a perfect heuristic function. However, there is no such algorithm that can solve everything. BFS is fast and is guaranteed to find a solution, but it takes more memory. DFS saves memory but will not always gives the right answer. IDDFS will provide a optimal path but is much slower. In conclusion, every searching algorithm has its own pros and cons, but we decide to choose A-Star. 
    
	
	



\end{document}